\section{Geometrie}

\begin{algorithm}{Closest Pair}
	\begin{methods}
		\method{shortestDist}{kürzester Abstand zwischen Punkten}{n\*\log(n)}
	\end{methods}
	\sourcecode{geometry/closestPair.cpp}
\end{algorithm}

\begin{algorithm}{Konvexe Hülle}
	\begin{methods}
		\method{convexHull}{berechnet Konvexehülle}{n\*\log(n)}
	\end{methods}
	\begin{itemize}
		\item Konvexehülle gegen den Uhrzeigersinn Sortiert
		\item nur Eckpunkte enthalten(für alle Punkte = im CCW Test entfernen)
		\item Erster und Letzter Punkt sind identisch
	\end{itemize}
	\sourcecode{geometry/convexHull.cpp}
\end{algorithm}

\columnbreak
\begin{algorithm}{Rotating calipers}
	\begin{methods}
		\method{antipodalPoints}{berechnet antipodale Punkte}{n}
	\end{methods}
	\textbf{WICHTIG:} Punkte müssen gegen den Uhrzeigersinn Sortiert sein und konvexes Polygon bilden!
	\sourcecode{geometry/antipodalPoints.cpp}
\end{algorithm}

\subsection{Formeln~~--~\texttt{std::complex}}
\sourcecode{geometry/formulars.cpp}
\sourcecode{geometry/linesAndSegments.cpp}
\sourcecode{geometry/sortAround.cpp}
\input{geometry/triangle}
\sourcecode{geometry/triangle.cpp}
\sourcecode{geometry/polygon.cpp}
\sourcecode{geometry/circle.cpp}

\subsection{Formeln - 3D}
\sourcecode{geometry/formulars3d.cpp}

\optional{
	\subsection{3D-Kugeln}
	\sourcecode{geometry/spheres.cpp}
}

\begin{algorithm}{Half-plane intersection}
	\sourcecode{geometry/hpi.cpp}
\end{algorithm}

\begin{algorithm}[optional]{Delaunay Triangulierung}
	\begin{methods}
		\method{delaunay}{berechnet Triangulierung}{n\*\log(n)}
	\end{methods}
	\textbf{WICHTIG:} Wenn alle Punkte kollinear sind gibt es keine Traingulierung! Wenn 4 Punkte auf einem Kreis liegen ist die Triangulierung nicht eindeutig.
	\sourcecode{geometry/delaunay.cpp}
\end{algorithm}

\optional{
\subsection{Geraden}
\sourcecode{geometry/lines.cpp}
}
